{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>In this guide, we will walk you through configuring a system of microservices with Istio in sidecar mode.</p> <p>In the setup section, you will install Istio, deploy a sample application, configure a variety of service mesh resources (security and traffic policy) and verify that they all function.</p> <p>The subsequent section walks you through performing a migration to ambient mesh.  That is, eliminating the use of sidecars altogether, while at the same time preserving your mesh policies and configurations.</p> <p>Ambient mesh provides a stronger separation of your workloads from the mesh platform, where the proxies involved in implementing your policies are no longer coupled to your deployments.</p>"},{"location":"migrate/","title":"Migrating to Ambient","text":""},{"location":"migrate/#analysis","title":"Analysis","text":"<p>tbd</p>"},{"location":"migrate/#the-migration-tool","title":"The migration tool","text":"<ul> <li>download the migration tool</li> <li>migration plan</li> <li>perform the stepwise migration</li> </ul>"},{"location":"pre-analysis/","title":"Initial Considerations","text":""},{"location":"pre-analysis/#the-istio-cni-node-agent","title":"The Istio CNI node agent","text":"<p>In sidecar mode, Istio provides two ways for proxies to intercept traffic in and out of workloads:</p> <ol> <li>Iptables rules can be applied to route incoming and outgoing traffic to the sidecar on conventional ports</li> <li>The Istio CNI node agent is a newer method that was introduced to remove the requirement of running privileged containers to configure traffic redirection.</li> </ol> <p>As you plan your migration to ambient, your first consideration should be to migrate to using the Istio CNI node agent, as it is a requirement for ambient mode.</p>"},{"location":"pre-analysis/#the-kubernetes-gateway-api","title":"The Kubernetes Gateway API","text":"<p>The Kubernetes Gateway API is quickly becoming the new standard for implementing traffic policy, both at ingress and in the mesh.</p> <p>Istio has embraced the Kubernetes Gateway API, and ambient mode depends on it. The good news is that Istio supports the Gateway API in sidecar mode as well.</p> <p>Here too, as the Kubernetes gateway API becomes a requirement for Ambient, a first step towards migrating to ambient is opting to replace the use of the more venerable Istio APIs such as VirtualServices, Istio Gateways, and DestinationRules (for the purpose of defining subsets) with the newer Gateway API throughout.</p> <p>An advantage of performing this migration is gaining the ability to provision gateways dynamically at runtime, which provides increased flexibility.</p>"},{"location":"pre-analysis/#next","title":"Next..","text":"<p>In the next section, as we install Istio in sidecar mode, we opt to install the Istio CNI.</p> <p>Similarily, when configuring gateways and defining traffic policy, we opt for the newer Gateway API.</p> <p>Both decisions will put us in the position to focus on the migration to sidecarless without having to deal with these additional concerns.</p>"},{"location":"setup/","title":"Initial Setup","text":"<p>The objective of this activity is to construct an initial state, where:</p> <ol> <li>Istio is installed in sidecar mode.</li> <li>The sample application, <code>bookinfo</code>, is deployed with sidecars.</li> <li>An ingress gateway is deployed, and configured to route requests to the <code>productpage</code> service.</li> <li>A set of L4 and L7 authorization policies are in place and functioning.</li> <li>A traffic policy is in place that routes all requests for the <code>reviews</code> service to the <code>reviews-v3</code> workload.</li> </ol>"},{"location":"setup/#provisioning-a-kubernetes-cluster","title":"Provisioning a Kubernetes cluster","text":"<p>Feel free to provision a Kubernetes cluster of your choice, locally or in the cloud.</p> <p>The following snippet installs a local Kubernetes cluster with k3d.  For more information, see here.</p> <pre><code>k3d cluster create my-cluster \\\n    --api-port 6443 \\\n    --k3s-arg \"--disable=traefik@server:0\" \\\n    --port 80:80@loadbalancer \\\n    --port 443:443@loadbalancer\n</code></pre>"},{"location":"setup/#install-istio-in-sidecar-mode","title":"Install Istio in sidecar mode","text":"<p>Per the instructions for installing Istio in sidecar mode with Helm:</p> <p>Configure the Helm repository:</p> <pre><code>helm repo add istio https://istio-release.storage.googleapis.com/charts\nhelm repo update\n</code></pre> <p>Install the Istio CRDs:</p> <pre><code>helm install istio-base istio/base -n istio-system \\\n  --set defaultRevision=default --create-namespace\n</code></pre> <p>Install the Istio CNI:</p> <pre><code>helm install istio-cni istio/cni -n istio-system \\\n  --set global.platform=k3d --wait\n</code></pre> <p>About the <code>global.platform</code> flag</p> <p>The <code>global.platform</code> flag is a requirement on specific platforms when installing the Istio CNI.</p> <p>Install the <code>istiod</code> control plane:</p> <pre><code>helm install istiod istio/istiod -n istio-system --wait\n</code></pre>"},{"location":"setup/#validate","title":"Validate","text":"<p>Verify that both <code>istiod</code> and <code>istio-cni</code> pods are in Running state, in the <code>istio-system</code> namespace:</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> <p>List the helm releases in <code>istio-system</code>:</p> <pre><code>helm ls -n istio-system\n</code></pre>"},{"location":"setup/#deploy-bookinfo","title":"Deploy <code>bookinfo</code>","text":"<p>In this scenario, the <code>bookinfo</code> services are split across two namespaces:</p> <ul> <li>the <code>frontend</code> namespace hosts the <code>productpage</code> service</li> <li>the <code>backend</code> namespace hosts the services upstream from it: <code>reviews</code>, <code>ratings</code>, and <code>details</code></li> </ul> <p>Create the namespace:</p> <pre><code>kubectl create ns frontend\n</code></pre> <p>Label the namespace for sidecar injection:</p> <pre><code>kubectl label ns frontend istio-injection=enabled\n</code></pre> <p>Apply the manifests:</p> <pre><code>kubectl apply -f artifacts/bookinfo-frontend.yaml -n frontend \n</code></pre> <p>Repeat for the <code>backend</code> namespace:</p> <pre><code>kubectl create ns backend\nkubectl label ns backend istio-injection=enabled\nkubectl apply -f artifacts/bookinfo-backend.yaml -n backend\n</code></pre>"},{"location":"setup/#validate_1","title":"Validate","text":"<p>Verify that all pods have two containers, implying that the sidecar injection took place:</p> <pre><code>kubectl get pod -n frontend\nkubectl get pod -n backend\n</code></pre> <p>To help verify that the services are functioning, deploy a <code>curl</code> image to the cluster:</p> <pre><code>kubectl apply -n frontend -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/curl/curl.yaml\n</code></pre> <p>Make a test call to the <code>ratings</code> service:</p> <pre><code>kubectl exec deploy/curl -n frontend -- curl -s ratings.backend:9080/ratings/123 | jq\n</code></pre> <p>Call the <code>reviews</code> service:</p> <pre><code>kubectl exec deploy/curl -n frontend -- curl -s reviews.backend:9080/reviews/123 | jq\n</code></pre> <p>Finally, call the <code>productpage</code> service:</p> <pre><code> kubectl exec deploy/curl -n frontend -- curl -s productpage:9080/productpage | grep title\n</code></pre> <p>Make sure the calls succeed.</p>"},{"location":"setup/#configure-an-ingress-gateway","title":"Configure an ingress gateway","text":"<p>We have the option to use either the older Istio-specific method of statically provisioning a gateway with Helm, or the Kubernetes Gateway API which allows for the dynamic provisioning of gateways.</p> <p>We opt for the latter.</p> <p>Install the Kubernetes Gateway API standard channel CRDs:</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml\n</code></pre> <p>Create the namespace where the Gateway is to be provisioned:</p> <pre><code>kubectl create ns istio-ingress\n</code></pre> <p>Review the Gateway configuration:</p> gateway.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: http\n    hostname: \"bookinfo.example.com\"\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n            matchLabels:\n              kubernetes.io/metadata.name: frontend\n</code></pre> <p>The gateway is configured to allow the binding of routes defined in the namespace <code>frontend</code>.</p> <p>Apply the Gateway resource:</p> <pre><code>kubectl apply -f artifacts/gateway.yaml -n istio-ingress\n</code></pre> <p>Next, define an <code>HTTPRoute</code> to expose specific endpoints on the <code>productpage</code> service through the gateway:</p> ingress-route.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: productpage\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\"bookinfo.example.com\"]\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: /productpage\n    - path:\n        type: PathPrefix\n        value: /static\n    - path:\n        type: Exact\n        value: /login\n    - path:\n        type: Exact\n        value: /logout\n    - path:\n        type: PathPrefix\n        value: /api/v1/products\n    backendRefs:\n    - name: productpage\n      port: 9080\n</code></pre> <p>Apply the HTTPRoute:</p> <pre><code>kubectl apply -f artifacts/ingress-route.yaml -n frontend\n</code></pre>"},{"location":"setup/#validate_2","title":"Validate","text":"<p>Capture the external IP address of the Gateway:</p> <pre><code>export GW_IP=$(kubectl get gtw -n istio-ingress gateway \\\n  -ojsonpath='{.status.addresses[0].value}')\n</code></pre> <p>Make a curl request to the ingress gateway using the configured hostname <code>bookinfo.exmaple.com</code>:</p> <pre><code>curl -s bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP | grep title\n</code></pre>"},{"location":"setup/#configure-authorization-policies","title":"Configure authorization policies","text":"<p>You will apply three AuthorizationPolicy resources that establish the following policy:</p> <ol> <li>Only the ingress gateway should be able to make requests to the <code>productpage</code> service.</li> <li>Only <code>reviews</code> workloads can call the <code>ratings</code> service.</li> <li>Only <code>productpage</code> can make calls to the <code>details</code> service.</li> </ol> <p>Furthermore:</p> <ol> <li>The first policy will be a layer 4 policy that is concerned strictly with workload identity.</li> <li>The remaining policies have layer 7 aspects that allows only specific HTTP methods (for example, GET or POST).</li> </ol> <p>Review all three policies:</p> productpage-authz.yaml<pre><code>---\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: productpage-authz\nspec:\n  selector:\n    matchLabels:\n      app: productpage\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        principals:\n        - cluster.local/ns/istio-ingress/sa/gateway-istio\n</code></pre> <p>Note how the identity of the allowed caller is specified via the Istio spiffe id which is a function of the workload's location (namespace) and service account.</p> ratings-authz.yaml<pre><code>---\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: ratings-authz\nspec:\n  selector:\n    matchLabels:\n      app: ratings\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        principals:\n        - cluster.local/ns/backend/sa/bookinfo-reviews\n    to:\n    - operation:\n        methods: [\"GET\", \"POST\"]\n</code></pre> details-authz.yaml<pre><code>---\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: details-authz\nspec:\n  selector:\n    matchLabels:\n      app: details\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        principals:\n        - cluster.local/ns/frontend/sa/bookinfo-productpage\n    to:\n    - operation:\n        methods: [\"GET\"]\n</code></pre> <p>Apply all three policies:</p> <pre><code>kubectl apply -f artifacts/productpage-authz.yaml -n frontend\n</code></pre> <pre><code>kubectl apply -f artifacts/ratings-authz.yaml -n backend\n</code></pre> <pre><code>kubectl apply -f artifacts/details-authz.yaml -n backend\n</code></pre>"},{"location":"setup/#validate_3","title":"Validate","text":"<ol> <li> <p>A request from an unauthorized workload to the <code>productpage</code> service should be denied:</p> <pre><code>kubectl exec deploy/curl -n frontend -- \\\n  curl -s --head productpage:9080/productpage\n</code></pre> </li> <li> <p>A request from an unauthorized workload to the <code>ratings</code> service should be denied:</p> <pre><code>kubectl exec deploy/curl -n frontend -- \\\n  curl -s ratings.backend:9080/ratings/123\n</code></pre> <p>It should produce a <code>HTTP/1.1 403 Forbidden</code> response.</p> </li> <li> <p>A request from an unauthorized workload to the <code>details</code> service should be denied:</p> <pre><code>kubectl exec deploy/curl -n frontend -- \\\n  curl -s details.backend:9080/details/123\n</code></pre> </li> <li> <p>A request through the ingress gateway to product page and upstream should succeed:</p> <pre><code>curl -s --head bookinfo.example.com/productpage \\\n  --resolve bookinfo.example.com:80:$GW_IP\n</code></pre> </li> </ol>"},{"location":"setup/#configure-traffic-policies","title":"Configure traffic policies","text":"<p>When <code>productpage</code> makes requests against the <code>reviews</code> service, the requests are load-balanced across all three versions of the service.</p> <p>Verify this by making several requests to the <code>productpage</code> service and \"grepping\" for the keyword \"reviews-\":</p> <pre><code>curl -s bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP | grep \"reviews-\"\n</code></pre> <p>Review the following traffic policy which will route all requests to <code>reviews-v3</code>:</p> route-reviews-v3.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: bookinfo-reviews\nspec:\n  parentRefs:\n  - name: reviews\n    kind: Service\n    group: \"\"\n  rules:\n  - backendRefs:\n    - name: reviews-v3\n      port: 9080\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f artifacts/route-reviews-v3.yaml -n backend\n</code></pre>"},{"location":"setup/#validate_4","title":"Validate","text":"<p>Verify that all requests are routed to version 3 by making repeated calls to <code>productpage</code>:</p> <pre><code>curl -s bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP | grep \"reviews-\"\n</code></pre>"},{"location":"setup/#summary","title":"Summary","text":"<p>We have configured our initial state:  a system of microservices functioning with Istio in sidecar mode, with a combination of L4 and L7 security policies, and a traffic policy applied to the <code>reviews</code> service.</p> <p>In the next section, we will work on migrating this system to Istio ambient mode.</p>"}]}